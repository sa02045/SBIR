# 클로저

클로저는 자바스크립트 고유의 개념이 아니라 함수가 일급 객체로 취급하기 위한 함수형 프로그래밍 언어의 특성이다.

| 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

1

```js
const x = 1;
function outerFunc() {
  const x = 10;
  function innerFunc() {
    console.log(x); //10
    // 내부 함수에서는 스코프체인을 통해 식별자 x를 상위스코프에서 참조할 수 있다
  }
  innerFunc();
}
outerFunc();
```

2.

```js
const x = 1;
function outerFunc() {
  const x = 10;
  innerFunc();
}

function innerFunc() {
  console.log(x); //1
}
```

## 렉시컬 스코프

| JS엔진은 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다

- 함수를 어디에서 호출했는지는 스코프에 영향을 주지 않는다
- 이를 정적 스코프(렉시컬 스코프)라고한다

스코프의 실체는 실행컨텍스트의 렉시컬 환경으로, 외부렉시컬환경에 대한 참조를 통해 상위 렉시컬환경과 연결된다 (스코프)

| 렉시컬 환경의 외부 렉시컬환경에 대한 참조는 함수정의가 평가되는 시점에서 정의된 위치에 따라 결정된다.

## 함수 객체의 내부 슬롯 `[Environment]`

함수 실행컨텍스트와 함수 객체를 구분하자. 함수객체에는 프로퍼티를 할당할 수 있다

| 함수는 자신의 내부 슬롯 `[Environment]`에 자신이 정의된 환경, 상위 스코프의 참조를 저장한다

`함수 렉시컬 환경`의 외부 렉시컬 환경에 대한 참조 = `함수 객체`의 내부슬롯 `[[Environment]]`에 저장된 렉시컬 환경의 참조가 할당된다

## 클로저와 렉시컬 환경

| 외부 함수보다 중첩함수가 더 오래 유지되는 경우, 중첩함수는 생명주기가 종료된 외부함수의 변수를 참조할 수 있는데, 이러한 중첩함수를 클로저라고 한다

```js
const x = 1;
function outer() {
  const x = 10;
  return function inner() {
    console.log(x);
  };
}

const innerFunc = outer();
innerFunc(); // 10
```

| outer 함수의 실행컨텍스트는 실행컨텍스트 스택에서 제거되지만, outer 함수의 렉시컬환경까지 소멸하는 것은 아니다

- inner함수 객체의 `[Environmnet]` 프러퍼티에는 outer 함수의 렉시컬 환경의 참조하고 있기 때문에 가비지 컬렉터의 대상이 되지않는다
- 내부함수라고 해도 외부함수의 식별자를 참조하지 않는 경우에는 클로저라고 볼 수 없다. 외부함수보다 더 오래살아남는 경우로 한정한다

- 클로저에 의해 참조되는 상위 스코프의 변수를 `자유변수`라고 한다.

## 클로저의 활용

| 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태를 안전하게 은닉하고 특정함수에게만 상태변경을 허용하기위해 사용된다

전역 변수 num을 두는 것보다 클로저로 숨겨서 함수를 호출할 때에만 참조할 수 있도록 은닉한다

```js
const increase = (function () {
  let num = 0;
  return function () {
    return ++num;
  };
})();
```

변수 값은 누군가에 의해 언제든지 변경할 수 있어 오류 발생의 원인이 될수 있다. 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에서 부수효과를 최대한 억제하기 위해 클로저는 적극적으로 사용한다

## 캡슐화와 정보 은닉

| 캡슐화는 객체의 상태와 동작을 하나로 묶는 것

| 은닉은 객체의 상태나 동작을 감출 목적

- 외부에 공개하지 않도록 감추어 적절치 못한 접근을 차단, 정보를 보호한다
